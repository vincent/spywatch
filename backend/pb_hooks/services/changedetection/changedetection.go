// Package changedetection provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package changedetection

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for CreateWatchFetchBackend.
const (
	CreateWatchFetchBackendHtmlRequests  CreateWatchFetchBackend = "html_requests"
	CreateWatchFetchBackendHtmlWebdriver CreateWatchFetchBackend = "html_webdriver"
)

// Defines values for CreateWatchMethod.
const (
	CreateWatchMethodDELETE CreateWatchMethod = "DELETE"
	CreateWatchMethodGET    CreateWatchMethod = "GET"
	CreateWatchMethodPOST   CreateWatchMethod = "POST"
	CreateWatchMethodPUT    CreateWatchMethod = "PUT"
)

// Defines values for CreateWatchNotificationFormat.
const (
	CreateWatchNotificationFormatHtml          CreateWatchNotificationFormat = "html"
	CreateWatchNotificationFormatHtmlcolor     CreateWatchNotificationFormat = "htmlcolor"
	CreateWatchNotificationFormatMarkdown      CreateWatchNotificationFormat = "markdown"
	CreateWatchNotificationFormatSystemDefault CreateWatchNotificationFormat = "System default"
	CreateWatchNotificationFormatText          CreateWatchNotificationFormat = "text"
)

// Defines values for CreateWatchProcessor.
const (
	CreateWatchProcessorRestockDiff  CreateWatchProcessor = "restock_diff"
	CreateWatchProcessorTextJsonDiff CreateWatchProcessor = "text_json_diff"
)

// Defines values for UpdateWatchFetchBackend.
const (
	UpdateWatchFetchBackendHtmlRequests  UpdateWatchFetchBackend = "html_requests"
	UpdateWatchFetchBackendHtmlWebdriver UpdateWatchFetchBackend = "html_webdriver"
)

// Defines values for UpdateWatchMethod.
const (
	UpdateWatchMethodDELETE UpdateWatchMethod = "DELETE"
	UpdateWatchMethodGET    UpdateWatchMethod = "GET"
	UpdateWatchMethodPOST   UpdateWatchMethod = "POST"
	UpdateWatchMethodPUT    UpdateWatchMethod = "PUT"
)

// Defines values for UpdateWatchNotificationFormat.
const (
	UpdateWatchNotificationFormatHtml          UpdateWatchNotificationFormat = "html"
	UpdateWatchNotificationFormatHtmlcolor     UpdateWatchNotificationFormat = "htmlcolor"
	UpdateWatchNotificationFormatMarkdown      UpdateWatchNotificationFormat = "markdown"
	UpdateWatchNotificationFormatSystemDefault UpdateWatchNotificationFormat = "System default"
	UpdateWatchNotificationFormatText          UpdateWatchNotificationFormat = "text"
)

// Defines values for UpdateWatchProcessor.
const (
	UpdateWatchProcessorRestockDiff  UpdateWatchProcessor = "restock_diff"
	UpdateWatchProcessorTextJsonDiff UpdateWatchProcessor = "text_json_diff"
)

// Defines values for WatchFetchBackend.
const (
	WatchFetchBackendHtmlRequests  WatchFetchBackend = "html_requests"
	WatchFetchBackendHtmlWebdriver WatchFetchBackend = "html_webdriver"
)

// Defines values for WatchMethod.
const (
	WatchMethodDELETE WatchMethod = "DELETE"
	WatchMethodGET    WatchMethod = "GET"
	WatchMethodPOST   WatchMethod = "POST"
	WatchMethodPUT    WatchMethod = "PUT"
)

// Defines values for WatchNotificationFormat.
const (
	WatchNotificationFormatHtml          WatchNotificationFormat = "html"
	WatchNotificationFormatHtmlcolor     WatchNotificationFormat = "htmlcolor"
	WatchNotificationFormatMarkdown      WatchNotificationFormat = "markdown"
	WatchNotificationFormatSystemDefault WatchNotificationFormat = "System default"
	WatchNotificationFormatText          WatchNotificationFormat = "text"
)

// Defines values for WatchProcessor.
const (
	WatchProcessorRestockDiff  WatchProcessor = "restock_diff"
	WatchProcessorTextJsonDiff WatchProcessor = "text_json_diff"
)

// Defines values for WatchBaseFetchBackend.
const (
	WatchBaseFetchBackendHtmlRequests  WatchBaseFetchBackend = "html_requests"
	WatchBaseFetchBackendHtmlWebdriver WatchBaseFetchBackend = "html_webdriver"
)

// Defines values for WatchBaseMethod.
const (
	WatchBaseMethodDELETE WatchBaseMethod = "DELETE"
	WatchBaseMethodGET    WatchBaseMethod = "GET"
	WatchBaseMethodPOST   WatchBaseMethod = "POST"
	WatchBaseMethodPUT    WatchBaseMethod = "PUT"
)

// Defines values for WatchBaseNotificationFormat.
const (
	WatchBaseNotificationFormatHtml          WatchBaseNotificationFormat = "html"
	WatchBaseNotificationFormatHtmlcolor     WatchBaseNotificationFormat = "htmlcolor"
	WatchBaseNotificationFormatMarkdown      WatchBaseNotificationFormat = "markdown"
	WatchBaseNotificationFormatSystemDefault WatchBaseNotificationFormat = "System default"
	WatchBaseNotificationFormatText          WatchBaseNotificationFormat = "text"
)

// Defines values for WatchBaseProcessor.
const (
	WatchBaseProcessorRestockDiff  WatchBaseProcessor = "restock_diff"
	WatchBaseProcessorTextJsonDiff WatchBaseProcessor = "text_json_diff"
)

// Defines values for GetTagParamsMuted.
const (
	GetTagParamsMutedMuted   GetTagParamsMuted = "muted"
	GetTagParamsMutedUnmuted GetTagParamsMuted = "unmuted"
)

// Defines values for GetTagParamsRecheck.
const (
	GetTagParamsRecheckTrue GetTagParamsRecheck = "true"
)

// Defines values for ListWatchesParamsRecheckAll.
const (
	ListWatchesParamsRecheckAllN1 ListWatchesParamsRecheckAll = "1"
)

// Defines values for GetWatchParamsRecheck.
const (
	GetWatchParamsRecheckN1   GetWatchParamsRecheck = "1"
	GetWatchParamsRecheckTrue GetWatchParamsRecheck = "true"
)

// Defines values for GetWatchParamsPaused.
const (
	Paused   GetWatchParamsPaused = "paused"
	Unpaused GetWatchParamsPaused = "unpaused"
)

// Defines values for GetWatchParamsMuted.
const (
	GetWatchParamsMutedMuted   GetWatchParamsMuted = "muted"
	GetWatchParamsMutedUnmuted GetWatchParamsMuted = "unmuted"
)

// Defines values for GetWatchSnapshotParamsHtml.
const (
	GetWatchSnapshotParamsHtmlN1 GetWatchSnapshotParamsHtml = "1"
)

// Defines values for GetWatchSnapshotParamsTimestamp1.
const (
	Latest GetWatchSnapshotParamsTimestamp1 = "latest"
)

// CreateTag defines model for CreateTag.
type CreateTag struct {
	// NotificationMuted Whether notifications are muted for this tag
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationUrls Default notification URLs for web page change monitors (watches) with this tag
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Title Tag title
	Title string `json:"title"`

	// Uuid Unique identifier for the tag
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`
}

// CreateWatch defines model for CreateWatch.
type CreateWatch struct {
	// Body HTTP request body
	Body *string `json:"body,omitempty"`

	// BrowserSteps Browser automation steps
	BrowserSteps *[]struct {
		Operation     string `json:"operation"`
		OptionalValue string `json:"optional_value"`
		Selector      string `json:"selector"`
	} `json:"browser_steps,omitempty"`

	// FetchBackend Backend to use for fetching content
	FetchBackend *CreateWatchFetchBackend `json:"fetch_backend,omitempty"`

	// Headers HTTP headers to include in requests
	Headers *map[string]string `json:"headers,omitempty"`

	// Method HTTP method to use
	Method *CreateWatchMethod `json:"method,omitempty"`

	// NotificationBody Custom notification body
	NotificationBody *string `json:"notification_body,omitempty"`

	// NotificationFormat Format for notifications
	NotificationFormat *CreateWatchNotificationFormat `json:"notification_format,omitempty"`

	// NotificationMuted Whether notifications are muted
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationTitle Custom notification title
	NotificationTitle *string `json:"notification_title,omitempty"`

	// NotificationUrls Notification URLs for this web page change monitor (watch)
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Paused Whether the web page change monitor (watch) is paused
	Paused *bool `json:"paused,omitempty"`

	// Processor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
	Processor *CreateWatchProcessor `json:"processor,omitempty"`

	// Proxy Proxy configuration
	Proxy *string `json:"proxy,omitempty"`

	// Tag Tag UUID to associate with this web page change monitor (watch)
	Tag *string `json:"tag,omitempty"`

	// Tags Array of tag UUIDs
	Tags *[]string `json:"tags,omitempty"`

	// TimeBetweenCheck Time intervals between checks
	TimeBetweenCheck *struct {
		Days    *int `json:"days,omitempty"`
		Hours   *int `json:"hours,omitempty"`
		Minutes *int `json:"minutes,omitempty"`
		Seconds *int `json:"seconds,omitempty"`
		Weeks   *int `json:"weeks,omitempty"`
	} `json:"time_between_check,omitempty"`

	// TimeBetweenCheckUseDefault Whether to use global settings for time between checks - defaults to true if not set
	TimeBetweenCheckUseDefault *bool `json:"time_between_check_use_default,omitempty"`

	// Title Custom title for the web page change monitor (watch), not to be confused with page_title
	Title *string `json:"title,omitempty"`

	// TrackLdjsonPriceData Whether to track JSON-LD price data
	TrackLdjsonPriceData *bool `json:"track_ldjson_price_data,omitempty"`

	// Url URL to monitor for changes
	Url string `json:"url"`

	// WebdriverDelay Delay in seconds for webdriver
	WebdriverDelay *int `json:"webdriver_delay,omitempty"`

	// WebdriverJsExecuteCode JavaScript code to execute
	WebdriverJsExecuteCode *string `json:"webdriver_js_execute_code,omitempty"`
}

// CreateWatchFetchBackend Backend to use for fetching content
type CreateWatchFetchBackend string

// CreateWatchMethod HTTP method to use
type CreateWatchMethod string

// CreateWatchNotificationFormat Format for notifications
type CreateWatchNotificationFormat string

// CreateWatchProcessor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
type CreateWatchProcessor string

// Error defines model for Error.
type Error struct {
	// Message Error message
	Message *string `json:"message,omitempty"`
}

// NotificationUrls defines model for NotificationUrls.
type NotificationUrls struct {
	// NotificationUrls List of notification URLs
	NotificationUrls []string `json:"notification_urls"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// Watches Dictionary of matching web page change monitors (watches) keyed by UUID
	Watches *map[string]Watch `json:"watches,omitempty"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	// TagCount Total number of tags
	TagCount *int `json:"tag_count,omitempty"`

	// Uptime System uptime
	Uptime *string `json:"uptime,omitempty"`

	// Version Application version
	Version *string `json:"version,omitempty"`

	// WatchCount Total number of web page change monitors (watches)
	WatchCount *int `json:"watch_count,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	// NotificationMuted Whether notifications are muted for this tag
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationUrls Default notification URLs for web page change monitors (watches) with this tag
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Title Tag title
	Title *string `json:"title,omitempty"`

	// Uuid Unique identifier for the tag
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`
}

// UpdateWatch defines model for UpdateWatch.
type UpdateWatch struct {
	// Body HTTP request body
	Body *string `json:"body,omitempty"`

	// BrowserSteps Browser automation steps
	BrowserSteps *[]struct {
		Operation     string `json:"operation"`
		OptionalValue string `json:"optional_value"`
		Selector      string `json:"selector"`
	} `json:"browser_steps,omitempty"`

	// FetchBackend Backend to use for fetching content
	FetchBackend *UpdateWatchFetchBackend `json:"fetch_backend,omitempty"`

	// Headers HTTP headers to include in requests
	Headers *map[string]string `json:"headers,omitempty"`

	// LastViewed Unix timestamp in seconds of the last time the watch was viewed. Setting it to a value higher than `last_changed` in the "Update watch" endpoint marks the watch as viewed.
	LastViewed *int `json:"last_viewed,omitempty"`

	// Method HTTP method to use
	Method *UpdateWatchMethod `json:"method,omitempty"`

	// NotificationBody Custom notification body
	NotificationBody *string `json:"notification_body,omitempty"`

	// NotificationFormat Format for notifications
	NotificationFormat *UpdateWatchNotificationFormat `json:"notification_format,omitempty"`

	// NotificationMuted Whether notifications are muted
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationTitle Custom notification title
	NotificationTitle *string `json:"notification_title,omitempty"`

	// NotificationUrls Notification URLs for this web page change monitor (watch)
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Paused Whether the web page change monitor (watch) is paused
	Paused *bool `json:"paused,omitempty"`

	// Processor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
	Processor *UpdateWatchProcessor `json:"processor,omitempty"`

	// Proxy Proxy configuration
	Proxy *string `json:"proxy,omitempty"`

	// Tag Tag UUID to associate with this web page change monitor (watch)
	Tag *string `json:"tag,omitempty"`

	// Tags Array of tag UUIDs
	Tags *[]string `json:"tags,omitempty"`

	// TimeBetweenCheck Time intervals between checks
	TimeBetweenCheck *struct {
		Days    *int `json:"days,omitempty"`
		Hours   *int `json:"hours,omitempty"`
		Minutes *int `json:"minutes,omitempty"`
		Seconds *int `json:"seconds,omitempty"`
		Weeks   *int `json:"weeks,omitempty"`
	} `json:"time_between_check,omitempty"`

	// TimeBetweenCheckUseDefault Whether to use global settings for time between checks - defaults to true if not set
	TimeBetweenCheckUseDefault *bool `json:"time_between_check_use_default,omitempty"`

	// Title Custom title for the web page change monitor (watch), not to be confused with page_title
	Title *string `json:"title,omitempty"`

	// TrackLdjsonPriceData Whether to track JSON-LD price data
	TrackLdjsonPriceData *bool `json:"track_ldjson_price_data,omitempty"`

	// Url URL to monitor for changes
	Url *string `json:"url,omitempty"`

	// WebdriverDelay Delay in seconds for webdriver
	WebdriverDelay *int `json:"webdriver_delay,omitempty"`

	// WebdriverJsExecuteCode JavaScript code to execute
	WebdriverJsExecuteCode *string `json:"webdriver_js_execute_code,omitempty"`
}

// UpdateWatchFetchBackend Backend to use for fetching content
type UpdateWatchFetchBackend string

// UpdateWatchMethod HTTP method to use
type UpdateWatchMethod string

// UpdateWatchNotificationFormat Format for notifications
type UpdateWatchNotificationFormat string

// UpdateWatchProcessor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
type UpdateWatchProcessor string

// Watch defines model for Watch.
type Watch struct {
	// Body HTTP request body
	Body *string `json:"body,omitempty"`

	// BrowserSteps Browser automation steps
	BrowserSteps *[]struct {
		Operation     string `json:"operation"`
		OptionalValue string `json:"optional_value"`
		Selector      string `json:"selector"`
	} `json:"browser_steps,omitempty"`

	// FetchBackend Backend to use for fetching content
	FetchBackend *WatchFetchBackend `json:"fetch_backend,omitempty"`

	// Headers HTTP headers to include in requests
	Headers *map[string]string `json:"headers,omitempty"`

	// LastChanged Unix timestamp of last change
	LastChanged *int `json:"last_changed,omitempty"`

	// LastChecked Unix timestamp of last check
	LastChecked *int `json:"last_checked,omitempty"`

	// LastError Last error message
	LastError *string `json:"last_error,omitempty"`

	// LastViewed Unix timestamp in seconds of the last time the watch was viewed. Setting it to a value higher than `last_changed` in the "Update watch" endpoint marks the watch as viewed.
	LastViewed *int `json:"last_viewed,omitempty"`

	// Link The watch URL rendered in case of any Jinja2 markup, always use this for listing.
	Link *string `json:"link,omitempty"`

	// Method HTTP method to use
	Method *WatchMethod `json:"method,omitempty"`

	// NotificationBody Custom notification body
	NotificationBody *string `json:"notification_body,omitempty"`

	// NotificationFormat Format for notifications
	NotificationFormat *WatchNotificationFormat `json:"notification_format,omitempty"`

	// NotificationMuted Whether notifications are muted
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationTitle Custom notification title
	NotificationTitle *string `json:"notification_title,omitempty"`

	// NotificationUrls Notification URLs for this web page change monitor (watch)
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Paused Whether the web page change monitor (watch) is paused
	Paused *bool `json:"paused,omitempty"`

	// Processor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
	Processor *WatchProcessor `json:"processor,omitempty"`

	// Proxy Proxy configuration
	Proxy *string `json:"proxy,omitempty"`

	// Tag Tag UUID to associate with this web page change monitor (watch)
	Tag *string `json:"tag,omitempty"`

	// Tags Array of tag UUIDs
	Tags *[]string `json:"tags,omitempty"`

	// TimeBetweenCheck Time intervals between checks
	TimeBetweenCheck *struct {
		Days    *int `json:"days,omitempty"`
		Hours   *int `json:"hours,omitempty"`
		Minutes *int `json:"minutes,omitempty"`
		Seconds *int `json:"seconds,omitempty"`
		Weeks   *int `json:"weeks,omitempty"`
	} `json:"time_between_check,omitempty"`

	// TimeBetweenCheckUseDefault Whether to use global settings for time between checks - defaults to true if not set
	TimeBetweenCheckUseDefault *bool `json:"time_between_check_use_default,omitempty"`

	// Title Custom title for the web page change monitor (watch), not to be confused with page_title
	Title *string `json:"title,omitempty"`

	// TrackLdjsonPriceData Whether to track JSON-LD price data
	TrackLdjsonPriceData *bool `json:"track_ldjson_price_data,omitempty"`

	// Url URL to monitor for changes
	Url *string `json:"url,omitempty"`

	// Uuid Unique identifier for the web page change monitor (watch)
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`

	// WebdriverDelay Delay in seconds for webdriver
	WebdriverDelay *int `json:"webdriver_delay,omitempty"`

	// WebdriverJsExecuteCode JavaScript code to execute
	WebdriverJsExecuteCode *string `json:"webdriver_js_execute_code,omitempty"`
}

// WatchFetchBackend Backend to use for fetching content
type WatchFetchBackend string

// WatchMethod HTTP method to use
type WatchMethod string

// WatchNotificationFormat Format for notifications
type WatchNotificationFormat string

// WatchProcessor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
type WatchProcessor string

// WatchBase defines model for WatchBase.
type WatchBase struct {
	// Body HTTP request body
	Body *string `json:"body,omitempty"`

	// BrowserSteps Browser automation steps
	BrowserSteps *[]struct {
		Operation     string `json:"operation"`
		OptionalValue string `json:"optional_value"`
		Selector      string `json:"selector"`
	} `json:"browser_steps,omitempty"`

	// FetchBackend Backend to use for fetching content
	FetchBackend *WatchBaseFetchBackend `json:"fetch_backend,omitempty"`

	// Headers HTTP headers to include in requests
	Headers *map[string]string `json:"headers,omitempty"`

	// Method HTTP method to use
	Method *WatchBaseMethod `json:"method,omitempty"`

	// NotificationBody Custom notification body
	NotificationBody *string `json:"notification_body,omitempty"`

	// NotificationFormat Format for notifications
	NotificationFormat *WatchBaseNotificationFormat `json:"notification_format,omitempty"`

	// NotificationMuted Whether notifications are muted
	NotificationMuted *bool `json:"notification_muted,omitempty"`

	// NotificationTitle Custom notification title
	NotificationTitle *string `json:"notification_title,omitempty"`

	// NotificationUrls Notification URLs for this web page change monitor (watch)
	NotificationUrls *[]string `json:"notification_urls,omitempty"`

	// Paused Whether the web page change monitor (watch) is paused
	Paused *bool `json:"paused,omitempty"`

	// Processor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
	Processor *WatchBaseProcessor `json:"processor,omitempty"`

	// Proxy Proxy configuration
	Proxy *string `json:"proxy,omitempty"`

	// Tag Tag UUID to associate with this web page change monitor (watch)
	Tag *string `json:"tag,omitempty"`

	// Tags Array of tag UUIDs
	Tags *[]string `json:"tags,omitempty"`

	// TimeBetweenCheck Time intervals between checks
	TimeBetweenCheck *struct {
		Days    *int `json:"days,omitempty"`
		Hours   *int `json:"hours,omitempty"`
		Minutes *int `json:"minutes,omitempty"`
		Seconds *int `json:"seconds,omitempty"`
		Weeks   *int `json:"weeks,omitempty"`
	} `json:"time_between_check,omitempty"`

	// TimeBetweenCheckUseDefault Whether to use global settings for time between checks - defaults to true if not set
	TimeBetweenCheckUseDefault *bool `json:"time_between_check_use_default,omitempty"`

	// Title Custom title for the web page change monitor (watch), not to be confused with page_title
	Title *string `json:"title,omitempty"`

	// TrackLdjsonPriceData Whether to track JSON-LD price data
	TrackLdjsonPriceData *bool `json:"track_ldjson_price_data,omitempty"`

	// Url URL to monitor for changes
	Url *string `json:"url,omitempty"`

	// WebdriverDelay Delay in seconds for webdriver
	WebdriverDelay *int `json:"webdriver_delay,omitempty"`

	// WebdriverJsExecuteCode JavaScript code to execute
	WebdriverJsExecuteCode *string `json:"webdriver_js_execute_code,omitempty"`
}

// WatchBaseFetchBackend Backend to use for fetching content
type WatchBaseFetchBackend string

// WatchBaseMethod HTTP method to use
type WatchBaseMethod string

// WatchBaseNotificationFormat Format for notifications
type WatchBaseNotificationFormat string

// WatchBaseProcessor Optional processor mode to use for change detection. Defaults to `text_json_diff` if not specified.
type WatchBaseProcessor string

// WatchHistory Dictionary of timestamps and snapshot paths
type WatchHistory map[string]string

// ImportWatchesTextBody defines parameters for ImportWatches.
type ImportWatchesTextBody = string

// ImportWatchesParams defines parameters for ImportWatches.
type ImportWatchesParams struct {
	// TagUuids Tag UUID to apply to imported web page change monitors (watches)
	TagUuids *string `form:"tag_uuids,omitempty" json:"tag_uuids,omitempty"`

	// Tag Tag name to apply to imported web page change monitors (watches)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Proxy Proxy key to use for imported web page change monitors (watches)
	Proxy *string `form:"proxy,omitempty" json:"proxy,omitempty"`

	// Dedupe Remove duplicate URLs (default true)
	Dedupe *bool `form:"dedupe,omitempty" json:"dedupe,omitempty"`
}

// SearchWatchesParams defines parameters for SearchWatches.
type SearchWatchesParams struct {
	// Q Search query to match against watch URLs and titles
	Q string `form:"q" json:"q"`

	// Tag Tag name to limit results (name not UUID)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Partial Allow partial matching of URL query
	Partial *string `form:"partial,omitempty" json:"partial,omitempty"`
}

// GetTagParams defines parameters for GetTag.
type GetTagParams struct {
	// Muted Set mute state
	Muted *GetTagParamsMuted `form:"muted,omitempty" json:"muted,omitempty"`

	// Recheck Queue all web page change monitors (watches) with this tag for recheck
	Recheck *GetTagParamsRecheck `form:"recheck,omitempty" json:"recheck,omitempty"`
}

// GetTagParamsMuted defines parameters for GetTag.
type GetTagParamsMuted string

// GetTagParamsRecheck defines parameters for GetTag.
type GetTagParamsRecheck string

// ListWatchesParams defines parameters for ListWatches.
type ListWatchesParams struct {
	// RecheckAll Set to 1 to force recheck of all watches
	RecheckAll *ListWatchesParamsRecheckAll `form:"recheck_all,omitempty" json:"recheck_all,omitempty"`

	// Tag Tag name to filter results
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// ListWatchesParamsRecheckAll defines parameters for ListWatches.
type ListWatchesParamsRecheckAll string

// GetWatchParams defines parameters for GetWatch.
type GetWatchParams struct {
	// Recheck Recheck this web page change monitor (watch)
	Recheck *GetWatchParamsRecheck `form:"recheck,omitempty" json:"recheck,omitempty"`

	// Paused Set pause state
	Paused *GetWatchParamsPaused `form:"paused,omitempty" json:"paused,omitempty"`

	// Muted Set mute state
	Muted *GetWatchParamsMuted `form:"muted,omitempty" json:"muted,omitempty"`
}

// GetWatchParamsRecheck defines parameters for GetWatch.
type GetWatchParamsRecheck string

// GetWatchParamsPaused defines parameters for GetWatch.
type GetWatchParamsPaused string

// GetWatchParamsMuted defines parameters for GetWatch.
type GetWatchParamsMuted string

// GetWatchSnapshotParams defines parameters for GetWatchSnapshot.
type GetWatchSnapshotParams struct {
	// Html Set to 1 to return the last HTML
	Html *GetWatchSnapshotParamsHtml `form:"html,omitempty" json:"html,omitempty"`
}

// GetWatchSnapshotParamsHtml defines parameters for GetWatchSnapshot.
type GetWatchSnapshotParamsHtml string

// GetWatchSnapshotParamsTimestamp0 defines parameters for GetWatchSnapshot.
type GetWatchSnapshotParamsTimestamp0 = int

// GetWatchSnapshotParamsTimestamp1 defines parameters for GetWatchSnapshot.
type GetWatchSnapshotParamsTimestamp1 string

// ImportWatchesTextRequestBody defines body for ImportWatches for text/plain ContentType.
type ImportWatchesTextRequestBody = ImportWatchesTextBody

// DeleteNotificationsJSONRequestBody defines body for DeleteNotifications for application/json ContentType.
type DeleteNotificationsJSONRequestBody = NotificationUrls

// AddNotificationsJSONRequestBody defines body for AddNotifications for application/json ContentType.
type AddNotificationsJSONRequestBody = NotificationUrls

// ReplaceNotificationsJSONRequestBody defines body for ReplaceNotifications for application/json ContentType.
type ReplaceNotificationsJSONRequestBody = NotificationUrls

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = CreateTag

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = Tag

// CreateWatchJSONRequestBody defines body for CreateWatch for application/json ContentType.
type CreateWatchJSONRequestBody = CreateWatch

// UpdateWatchJSONRequestBody defines body for UpdateWatch for application/json ContentType.
type UpdateWatchJSONRequestBody = UpdateWatch

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ImportWatchesWithBody request with any body
	ImportWatchesWithBody(ctx context.Context, params *ImportWatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportWatchesWithTextBody(ctx context.Context, params *ImportWatchesParams, body ImportWatchesTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationsWithBody request with any body
	DeleteNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteNotifications(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotifications request
	GetNotifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNotificationsWithBody request with any body
	AddNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddNotifications(ctx context.Context, body AddNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceNotificationsWithBody request with any body
	ReplaceNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceNotifications(ctx context.Context, body ReplaceNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWatches request
	SearchWatches(ctx context.Context, params *SearchWatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInfo request
	GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagWithBody request with any body
	CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, uuid openapi_types.UUID, params *GetTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTagWithBody request with any body
	UpdateTagWithBody(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTag(ctx context.Context, uuid openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTags request
	ListTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWatches request
	ListWatches(ctx context.Context, params *ListWatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWatchWithBody request with any body
	CreateWatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWatch(ctx context.Context, body CreateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWatch request
	DeleteWatch(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatch request
	GetWatch(ctx context.Context, uuid openapi_types.UUID, params *GetWatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWatchWithBody request with any body
	UpdateWatchWithBody(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWatch(ctx context.Context, uuid openapi_types.UUID, body UpdateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchFavicon request
	GetWatchFavicon(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchHistory request
	GetWatchHistory(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchSnapshot request
	GetWatchSnapshot(ctx context.Context, uuid openapi_types.UUID, timestamp string, params *GetWatchSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ImportWatchesWithBody(ctx context.Context, params *ImportWatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportWatchesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportWatchesWithTextBody(ctx context.Context, params *ImportWatchesParams, body ImportWatchesTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportWatchesRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotifications(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNotificationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNotifications(ctx context.Context, body AddNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNotificationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNotificationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNotifications(ctx context.Context, body ReplaceNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNotificationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWatches(ctx context.Context, params *SearchWatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, uuid openapi_types.UUID, params *GetTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithBody(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTag(ctx context.Context, uuid openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWatches(ctx context.Context, params *ListWatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWatch(ctx context.Context, body CreateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWatch(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWatchRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatch(ctx context.Context, uuid openapi_types.UUID, params *GetWatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchRequest(c.Server, uuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWatchWithBody(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWatchRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWatch(ctx context.Context, uuid openapi_types.UUID, body UpdateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWatchRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchFavicon(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchFaviconRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchHistory(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchHistoryRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchSnapshot(ctx context.Context, uuid openapi_types.UUID, timestamp string, params *GetWatchSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchSnapshotRequest(c.Server, uuid, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewImportWatchesRequestWithTextBody calls the generic ImportWatches builder with text/plain body
func NewImportWatchesRequestWithTextBody(server string, params *ImportWatchesParams, body ImportWatchesTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewImportWatchesRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewImportWatchesRequestWithBody generates requests for ImportWatches with any type of body
func NewImportWatchesRequestWithBody(server string, params *ImportWatchesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TagUuids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag_uuids", runtime.ParamLocationQuery, *params.TagUuids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Proxy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proxy", runtime.ParamLocationQuery, *params.Proxy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dedupe != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dedupe", runtime.ParamLocationQuery, *params.Dedupe); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationsRequest calls the generic DeleteNotifications builder with application/json body
func NewDeleteNotificationsRequest(server string, body DeleteNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteNotificationsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteNotificationsRequestWithBody generates requests for DeleteNotifications with any type of body
func NewDeleteNotificationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationsRequest generates requests for GetNotifications
func NewGetNotificationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddNotificationsRequest calls the generic AddNotifications builder with application/json body
func NewAddNotificationsRequest(server string, body AddNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddNotificationsRequestWithBody(server, "application/json", bodyReader)
}

// NewAddNotificationsRequestWithBody generates requests for AddNotifications with any type of body
func NewAddNotificationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceNotificationsRequest calls the generic ReplaceNotifications builder with application/json body
func NewReplaceNotificationsRequest(server string, body ReplaceNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceNotificationsRequestWithBody(server, "application/json", bodyReader)
}

// NewReplaceNotificationsRequestWithBody generates requests for ReplaceNotifications with any type of body
func NewReplaceNotificationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchWatchesRequest generates requests for SearchWatches
func NewSearchWatchesRequest(server string, params *SearchWatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partial != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partial", runtime.ParamLocationQuery, *params.Partial); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemInfoRequest generates requests for GetSystemInfo
func NewGetSystemInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systeminfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, uuid openapi_types.UUID, params *GetTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Muted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "muted", runtime.ParamLocationQuery, *params.Muted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recheck", runtime.ParamLocationQuery, *params.Recheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTagRequest calls the generic UpdateTag builder with application/json body
func NewUpdateTagRequest(server string, uuid openapi_types.UUID, body UpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTagRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateTagRequestWithBody generates requests for UpdateTag with any type of body
func NewUpdateTagRequestWithBody(server string, uuid openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tag/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTagsRequest generates requests for ListTags
func NewListTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWatchesRequest generates requests for ListWatches
func NewListWatchesRequest(server string, params *ListWatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RecheckAll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recheck_all", runtime.ParamLocationQuery, *params.RecheckAll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWatchRequest calls the generic CreateWatch builder with application/json body
func NewCreateWatchRequest(server string, body CreateWatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWatchRequestWithBody generates requests for CreateWatch with any type of body
func NewCreateWatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWatchRequest generates requests for DeleteWatch
func NewDeleteWatchRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchRequest generates requests for GetWatch
func NewGetWatchRequest(server string, uuid openapi_types.UUID, params *GetWatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Recheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recheck", runtime.ParamLocationQuery, *params.Recheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paused != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paused", runtime.ParamLocationQuery, *params.Paused); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Muted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "muted", runtime.ParamLocationQuery, *params.Muted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWatchRequest calls the generic UpdateWatch builder with application/json body
func NewUpdateWatchRequest(server string, uuid openapi_types.UUID, body UpdateWatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWatchRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewUpdateWatchRequestWithBody generates requests for UpdateWatch with any type of body
func NewUpdateWatchRequestWithBody(server string, uuid openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWatchFaviconRequest generates requests for GetWatchFavicon
func NewGetWatchFaviconRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s/favicon", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchHistoryRequest generates requests for GetWatchHistory
func NewGetWatchHistoryRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchSnapshotRequest generates requests for GetWatchSnapshot
func NewGetWatchSnapshotRequest(server string, uuid openapi_types.UUID, timestamp string, params *GetWatchSnapshotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/%s/history/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Html != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "html", runtime.ParamLocationQuery, *params.Html); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ImportWatchesWithBodyWithResponse request with any body
	ImportWatchesWithBodyWithResponse(ctx context.Context, params *ImportWatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportWatchesResponse, error)

	ImportWatchesWithTextBodyWithResponse(ctx context.Context, params *ImportWatchesParams, body ImportWatchesTextRequestBody, reqEditors ...RequestEditorFn) (*ImportWatchesResponse, error)

	// DeleteNotificationsWithBodyWithResponse request with any body
	DeleteNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error)

	DeleteNotificationsWithResponse(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error)

	// GetNotificationsWithResponse request
	GetNotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error)

	// AddNotificationsWithBodyWithResponse request with any body
	AddNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNotificationsResponse, error)

	AddNotificationsWithResponse(ctx context.Context, body AddNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNotificationsResponse, error)

	// ReplaceNotificationsWithBodyWithResponse request with any body
	ReplaceNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNotificationsResponse, error)

	ReplaceNotificationsWithResponse(ctx context.Context, body ReplaceNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNotificationsResponse, error)

	// SearchWatchesWithResponse request
	SearchWatchesWithResponse(ctx context.Context, params *SearchWatchesParams, reqEditors ...RequestEditorFn) (*SearchWatchesResponse, error)

	// GetSystemInfoWithResponse request
	GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error)

	// CreateTagWithBodyWithResponse request with any body
	CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTagWithResponse request
	GetTagWithResponse(ctx context.Context, uuid openapi_types.UUID, params *GetTagParams, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// UpdateTagWithBodyWithResponse request with any body
	UpdateTagWithBodyWithResponse(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithResponse(ctx context.Context, uuid openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	// ListTagsWithResponse request
	ListTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTagsResponse, error)

	// ListWatchesWithResponse request
	ListWatchesWithResponse(ctx context.Context, params *ListWatchesParams, reqEditors ...RequestEditorFn) (*ListWatchesResponse, error)

	// CreateWatchWithBodyWithResponse request with any body
	CreateWatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWatchResponse, error)

	CreateWatchWithResponse(ctx context.Context, body CreateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWatchResponse, error)

	// DeleteWatchWithResponse request
	DeleteWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWatchResponse, error)

	// GetWatchWithResponse request
	GetWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, params *GetWatchParams, reqEditors ...RequestEditorFn) (*GetWatchResponse, error)

	// UpdateWatchWithBodyWithResponse request with any body
	UpdateWatchWithBodyWithResponse(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWatchResponse, error)

	UpdateWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, body UpdateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWatchResponse, error)

	// GetWatchFaviconWithResponse request
	GetWatchFaviconWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWatchFaviconResponse, error)

	// GetWatchHistoryWithResponse request
	GetWatchHistoryWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWatchHistoryResponse, error)

	// GetWatchSnapshotWithResponse request
	GetWatchSnapshotWithResponse(ctx context.Context, uuid openapi_types.UUID, timestamp string, params *GetWatchSnapshotParams, reqEditors ...RequestEditorFn) (*GetWatchSnapshotResponse, error)
}

type ImportWatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]openapi_types.UUID
}

// Status returns HTTPResponse.Status
func (r ImportWatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportWatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationUrls
}

// Status returns HTTPResponse.Status
func (r GetNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NotificationUrls
}

// Status returns HTTPResponse.Status
func (r AddNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationUrls
}

// Status returns HTTPResponse.Status
func (r ReplaceNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResult
}

// Status returns HTTPResponse.Status
func (r SearchWatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfo
}

// Status returns HTTPResponse.Status
func (r GetSystemInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Uuid UUID of the created tag
		Uuid *openapi_types.UUID `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tag
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Tag
}

// Status returns HTTPResponse.Status
func (r ListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Watch
}

// Status returns HTTPResponse.Status
func (r ListWatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Watch
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchFaviconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWatchFaviconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchFaviconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WatchHistory
}

// Status returns HTTPResponse.Status
func (r GetWatchHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWatchSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ImportWatchesWithBodyWithResponse request with arbitrary body returning *ImportWatchesResponse
func (c *ClientWithResponses) ImportWatchesWithBodyWithResponse(ctx context.Context, params *ImportWatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportWatchesResponse, error) {
	rsp, err := c.ImportWatchesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportWatchesResponse(rsp)
}

func (c *ClientWithResponses) ImportWatchesWithTextBodyWithResponse(ctx context.Context, params *ImportWatchesParams, body ImportWatchesTextRequestBody, reqEditors ...RequestEditorFn) (*ImportWatchesResponse, error) {
	rsp, err := c.ImportWatchesWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportWatchesResponse(rsp)
}

// DeleteNotificationsWithBodyWithResponse request with arbitrary body returning *DeleteNotificationsResponse
func (c *ClientWithResponses) DeleteNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error) {
	rsp, err := c.DeleteNotificationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsResponse(rsp)
}

func (c *ClientWithResponses) DeleteNotificationsWithResponse(ctx context.Context, body DeleteNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error) {
	rsp, err := c.DeleteNotifications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsResponse(rsp)
}

// GetNotificationsWithResponse request returning *GetNotificationsResponse
func (c *ClientWithResponses) GetNotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error) {
	rsp, err := c.GetNotifications(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsResponse(rsp)
}

// AddNotificationsWithBodyWithResponse request with arbitrary body returning *AddNotificationsResponse
func (c *ClientWithResponses) AddNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNotificationsResponse, error) {
	rsp, err := c.AddNotificationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNotificationsResponse(rsp)
}

func (c *ClientWithResponses) AddNotificationsWithResponse(ctx context.Context, body AddNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNotificationsResponse, error) {
	rsp, err := c.AddNotifications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNotificationsResponse(rsp)
}

// ReplaceNotificationsWithBodyWithResponse request with arbitrary body returning *ReplaceNotificationsResponse
func (c *ClientWithResponses) ReplaceNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNotificationsResponse, error) {
	rsp, err := c.ReplaceNotificationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNotificationsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceNotificationsWithResponse(ctx context.Context, body ReplaceNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNotificationsResponse, error) {
	rsp, err := c.ReplaceNotifications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNotificationsResponse(rsp)
}

// SearchWatchesWithResponse request returning *SearchWatchesResponse
func (c *ClientWithResponses) SearchWatchesWithResponse(ctx context.Context, params *SearchWatchesParams, reqEditors ...RequestEditorFn) (*SearchWatchesResponse, error) {
	rsp, err := c.SearchWatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWatchesResponse(rsp)
}

// GetSystemInfoWithResponse request returning *GetSystemInfoResponse
func (c *ClientWithResponses) GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error) {
	rsp, err := c.GetSystemInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInfoResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, uuid openapi_types.UUID, params *GetTagParams, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// UpdateTagWithBodyWithResponse request with arbitrary body returning *UpdateTagResponse
func (c *ClientWithResponses) UpdateTagWithBodyWithResponse(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithResponse(ctx context.Context, uuid openapi_types.UUID, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTag(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

// ListTagsWithResponse request returning *ListTagsResponse
func (c *ClientWithResponses) ListTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTagsResponse, error) {
	rsp, err := c.ListTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsResponse(rsp)
}

// ListWatchesWithResponse request returning *ListWatchesResponse
func (c *ClientWithResponses) ListWatchesWithResponse(ctx context.Context, params *ListWatchesParams, reqEditors ...RequestEditorFn) (*ListWatchesResponse, error) {
	rsp, err := c.ListWatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWatchesResponse(rsp)
}

// CreateWatchWithBodyWithResponse request with arbitrary body returning *CreateWatchResponse
func (c *ClientWithResponses) CreateWatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWatchResponse, error) {
	rsp, err := c.CreateWatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWatchResponse(rsp)
}

func (c *ClientWithResponses) CreateWatchWithResponse(ctx context.Context, body CreateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWatchResponse, error) {
	rsp, err := c.CreateWatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWatchResponse(rsp)
}

// DeleteWatchWithResponse request returning *DeleteWatchResponse
func (c *ClientWithResponses) DeleteWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWatchResponse, error) {
	rsp, err := c.DeleteWatch(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWatchResponse(rsp)
}

// GetWatchWithResponse request returning *GetWatchResponse
func (c *ClientWithResponses) GetWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, params *GetWatchParams, reqEditors ...RequestEditorFn) (*GetWatchResponse, error) {
	rsp, err := c.GetWatch(ctx, uuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchResponse(rsp)
}

// UpdateWatchWithBodyWithResponse request with arbitrary body returning *UpdateWatchResponse
func (c *ClientWithResponses) UpdateWatchWithBodyWithResponse(ctx context.Context, uuid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWatchResponse, error) {
	rsp, err := c.UpdateWatchWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateWatchWithResponse(ctx context.Context, uuid openapi_types.UUID, body UpdateWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWatchResponse, error) {
	rsp, err := c.UpdateWatch(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWatchResponse(rsp)
}

// GetWatchFaviconWithResponse request returning *GetWatchFaviconResponse
func (c *ClientWithResponses) GetWatchFaviconWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWatchFaviconResponse, error) {
	rsp, err := c.GetWatchFavicon(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchFaviconResponse(rsp)
}

// GetWatchHistoryWithResponse request returning *GetWatchHistoryResponse
func (c *ClientWithResponses) GetWatchHistoryWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWatchHistoryResponse, error) {
	rsp, err := c.GetWatchHistory(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchHistoryResponse(rsp)
}

// GetWatchSnapshotWithResponse request returning *GetWatchSnapshotResponse
func (c *ClientWithResponses) GetWatchSnapshotWithResponse(ctx context.Context, uuid openapi_types.UUID, timestamp string, params *GetWatchSnapshotParams, reqEditors ...RequestEditorFn) (*GetWatchSnapshotResponse, error) {
	rsp, err := c.GetWatchSnapshot(ctx, uuid, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchSnapshotResponse(rsp)
}

// ParseImportWatchesResponse parses an HTTP response from a ImportWatchesWithResponse call
func ParseImportWatchesResponse(rsp *http.Response) (*ImportWatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportWatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []openapi_types.UUID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationsResponse parses an HTTP response from a DeleteNotificationsWithResponse call
func ParseDeleteNotificationsResponse(rsp *http.Response) (*DeleteNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNotificationsResponse parses an HTTP response from a GetNotificationsWithResponse call
func ParseGetNotificationsResponse(rsp *http.Response) (*GetNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationUrls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddNotificationsResponse parses an HTTP response from a AddNotificationsWithResponse call
func ParseAddNotificationsResponse(rsp *http.Response) (*AddNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationUrls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReplaceNotificationsResponse parses an HTTP response from a ReplaceNotificationsWithResponse call
func ParseReplaceNotificationsResponse(rsp *http.Response) (*ReplaceNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationUrls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchWatchesResponse parses an HTTP response from a SearchWatchesWithResponse call
func ParseSearchWatchesResponse(rsp *http.Response) (*SearchWatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSystemInfoResponse parses an HTTP response from a GetSystemInfoWithResponse call
func ParseGetSystemInfoResponse(rsp *http.Response) (*GetSystemInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Uuid UUID of the created tag
			Uuid *openapi_types.UUID `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseUpdateTagResponse parses an HTTP response from a UpdateTagWithResponse call
func ParseUpdateTagResponse(rsp *http.Response) (*UpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTagsResponse parses an HTTP response from a ListTagsWithResponse call
func ParseListTagsResponse(rsp *http.Response) (*ListTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWatchesResponse parses an HTTP response from a ListWatchesWithResponse call
func ParseListWatchesResponse(rsp *http.Response) (*ListWatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Watch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWatchResponse parses an HTTP response from a CreateWatchWithResponse call
func ParseCreateWatchResponse(rsp *http.Response) (*CreateWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWatchResponse parses an HTTP response from a DeleteWatchWithResponse call
func ParseDeleteWatchResponse(rsp *http.Response) (*DeleteWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWatchResponse parses an HTTP response from a GetWatchWithResponse call
func ParseGetWatchResponse(rsp *http.Response) (*GetWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Watch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseUpdateWatchResponse parses an HTTP response from a UpdateWatchWithResponse call
func ParseUpdateWatchResponse(rsp *http.Response) (*UpdateWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWatchFaviconResponse parses an HTTP response from a GetWatchFaviconWithResponse call
func ParseGetWatchFaviconResponse(rsp *http.Response) (*GetWatchFaviconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchFaviconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWatchHistoryResponse parses an HTTP response from a GetWatchHistoryWithResponse call
func ParseGetWatchHistoryResponse(rsp *http.Response) (*GetWatchHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WatchHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWatchSnapshotResponse parses an HTTP response from a GetWatchSnapshotWithResponse call
func ParseGetWatchSnapshotResponse(rsp *http.Response) (*GetWatchSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Import watch URLs
	// (POST /import)
	ImportWatches(ctx echo.Context, params ImportWatchesParams) error
	// Delete notification URLs
	// (DELETE /notifications)
	DeleteNotifications(ctx echo.Context) error
	// Get notification URLs
	// (GET /notifications)
	GetNotifications(ctx echo.Context) error
	// Add notification URLs
	// (POST /notifications)
	AddNotifications(ctx echo.Context) error
	// Replace notification URLs
	// (PUT /notifications)
	ReplaceNotifications(ctx echo.Context) error
	// Search watches
	// (GET /search)
	SearchWatches(ctx echo.Context, params SearchWatchesParams) error
	// Get system information
	// (GET /systeminfo)
	GetSystemInfo(ctx echo.Context) error
	// Create tag
	// (POST /tag)
	CreateTag(ctx echo.Context) error
	// Delete tag
	// (DELETE /tag/{uuid})
	DeleteTag(ctx echo.Context, uuid openapi_types.UUID) error
	// Get single tag
	// (GET /tag/{uuid})
	GetTag(ctx echo.Context, uuid openapi_types.UUID, params GetTagParams) error
	// Update tag
	// (PUT /tag/{uuid})
	UpdateTag(ctx echo.Context, uuid openapi_types.UUID) error
	// List all tags
	// (GET /tags)
	ListTags(ctx echo.Context) error
	// List all watches
	// (GET /watch)
	ListWatches(ctx echo.Context, params ListWatchesParams) error
	// Create a new watch
	// (POST /watch)
	CreateWatch(ctx echo.Context) error
	// Delete watch
	// (DELETE /watch/{uuid})
	DeleteWatch(ctx echo.Context, uuid openapi_types.UUID) error
	// Get single watch
	// (GET /watch/{uuid})
	GetWatch(ctx echo.Context, uuid openapi_types.UUID, params GetWatchParams) error
	// Update watch
	// (PUT /watch/{uuid})
	UpdateWatch(ctx echo.Context, uuid openapi_types.UUID) error
	// Get watch favicon
	// (GET /watch/{uuid}/favicon)
	GetWatchFavicon(ctx echo.Context, uuid openapi_types.UUID) error
	// Get watch history
	// (GET /watch/{uuid}/history)
	GetWatchHistory(ctx echo.Context, uuid openapi_types.UUID) error
	// Get single snapshot
	// (GET /watch/{uuid}/history/{timestamp})
	GetWatchSnapshot(ctx echo.Context, uuid openapi_types.UUID, timestamp string, params GetWatchSnapshotParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ImportWatches converts echo context to params.
func (w *ServerInterfaceWrapper) ImportWatches(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportWatchesParams
	// ------------- Optional query parameter "tag_uuids" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag_uuids", ctx.QueryParams(), &params.TagUuids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag_uuids: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "proxy" -------------

	err = runtime.BindQueryParameter("form", true, false, "proxy", ctx.QueryParams(), &params.Proxy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proxy: %s", err))
	}

	// ------------- Optional query parameter "dedupe" -------------

	err = runtime.BindQueryParameter("form", true, false, "dedupe", ctx.QueryParams(), &params.Dedupe)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dedupe: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportWatches(ctx, params)
	return err
}

// DeleteNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNotifications(ctx)
	return err
}

// GetNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotifications(ctx)
	return err
}

// AddNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) AddNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddNotifications(ctx)
	return err
}

// ReplaceNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) ReplaceNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReplaceNotifications(ctx)
	return err
}

// SearchWatches converts echo context to params.
func (w *ServerInterfaceWrapper) SearchWatches(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchWatchesParams
	// ------------- Required query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, true, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "partial" -------------

	err = runtime.BindQueryParameter("form", true, false, "partial", ctx.QueryParams(), &params.Partial)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partial: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchWatches(ctx, params)
	return err
}

// GetSystemInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemInfo(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemInfo(ctx)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, uuid)
	return err
}

// GetTag converts echo context to params.
func (w *ServerInterfaceWrapper) GetTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagParams
	// ------------- Optional query parameter "muted" -------------

	err = runtime.BindQueryParameter("form", true, false, "muted", ctx.QueryParams(), &params.Muted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter muted: %s", err))
	}

	// ------------- Optional query parameter "recheck" -------------

	err = runtime.BindQueryParameter("form", true, false, "recheck", ctx.QueryParams(), &params.Recheck)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recheck: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTag(ctx, uuid, params)
	return err
}

// UpdateTag converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTag(ctx, uuid)
	return err
}

// ListTags converts echo context to params.
func (w *ServerInterfaceWrapper) ListTags(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTags(ctx)
	return err
}

// ListWatches converts echo context to params.
func (w *ServerInterfaceWrapper) ListWatches(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWatchesParams
	// ------------- Optional query parameter "recheck_all" -------------

	err = runtime.BindQueryParameter("form", true, false, "recheck_all", ctx.QueryParams(), &params.RecheckAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recheck_all: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWatches(ctx, params)
	return err
}

// CreateWatch converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWatch(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWatch(ctx)
	return err
}

// DeleteWatch converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteWatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteWatch(ctx, uuid)
	return err
}

// GetWatch converts echo context to params.
func (w *ServerInterfaceWrapper) GetWatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWatchParams
	// ------------- Optional query parameter "recheck" -------------

	err = runtime.BindQueryParameter("form", true, false, "recheck", ctx.QueryParams(), &params.Recheck)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recheck: %s", err))
	}

	// ------------- Optional query parameter "paused" -------------

	err = runtime.BindQueryParameter("form", true, false, "paused", ctx.QueryParams(), &params.Paused)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paused: %s", err))
	}

	// ------------- Optional query parameter "muted" -------------

	err = runtime.BindQueryParameter("form", true, false, "muted", ctx.QueryParams(), &params.Muted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter muted: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWatch(ctx, uuid, params)
	return err
}

// UpdateWatch converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWatch(ctx, uuid)
	return err
}

// GetWatchFavicon converts echo context to params.
func (w *ServerInterfaceWrapper) GetWatchFavicon(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWatchFavicon(ctx, uuid)
	return err
}

// GetWatchHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetWatchHistory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWatchHistory(ctx, uuid)
	return err
}

// GetWatchSnapshot converts echo context to params.
func (w *ServerInterfaceWrapper) GetWatchSnapshot(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", ctx.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uuid: %s", err))
	}

	// ------------- Path parameter "timestamp" -------------
	var timestamp string

	err = runtime.BindStyledParameterWithOptions("simple", "timestamp", ctx.Param("timestamp"), &timestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timestamp: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWatchSnapshotParams
	// ------------- Optional query parameter "html" -------------

	err = runtime.BindQueryParameter("form", true, false, "html", ctx.QueryParams(), &params.Html)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter html: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWatchSnapshot(ctx, uuid, timestamp, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/import", wrapper.ImportWatches)
	router.DELETE(baseURL+"/notifications", wrapper.DeleteNotifications)
	router.GET(baseURL+"/notifications", wrapper.GetNotifications)
	router.POST(baseURL+"/notifications", wrapper.AddNotifications)
	router.PUT(baseURL+"/notifications", wrapper.ReplaceNotifications)
	router.GET(baseURL+"/search", wrapper.SearchWatches)
	router.GET(baseURL+"/systeminfo", wrapper.GetSystemInfo)
	router.POST(baseURL+"/tag", wrapper.CreateTag)
	router.DELETE(baseURL+"/tag/:uuid", wrapper.DeleteTag)
	router.GET(baseURL+"/tag/:uuid", wrapper.GetTag)
	router.PUT(baseURL+"/tag/:uuid", wrapper.UpdateTag)
	router.GET(baseURL+"/tags", wrapper.ListTags)
	router.GET(baseURL+"/watch", wrapper.ListWatches)
	router.POST(baseURL+"/watch", wrapper.CreateWatch)
	router.DELETE(baseURL+"/watch/:uuid", wrapper.DeleteWatch)
	router.GET(baseURL+"/watch/:uuid", wrapper.GetWatch)
	router.PUT(baseURL+"/watch/:uuid", wrapper.UpdateWatch)
	router.GET(baseURL+"/watch/:uuid/favicon", wrapper.GetWatchFavicon)
	router.GET(baseURL+"/watch/:uuid/history", wrapper.GetWatchHistory)
	router.GET(baseURL+"/watch/:uuid/history/:timestamp", wrapper.GetWatchSnapshot)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
